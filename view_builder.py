"""
VIEW Builder pour les modules de Business Intelligence
Générateur de VIEWs KPI avec préfixes standardisés et templates SQL
"""

import logging
from typing import Dict, List, Optional, Tuple, Any
from dataclasses import dataclass
from enum import Enum
import re

logger = logging.getLogger(__name__)

class ModuleType(Enum):
    """Types de modules métier supportés"""
    GMAO = "gmao"
    STOCKS = "stocks" 
    PURCHASES = "purchases"
    SALES = "sales"

@dataclass
class ViewDefinition:
    """Définition d'une VIEW KPI"""
    name: str
    module: ModuleType
    description: str
    base_tables: List[str]
    columns: Dict[str, str]  # column_alias: sql_expression
    joins: List[str]
    filters: List[str]
    group_by: List[str]
    order_by: List[str]
    comments: Dict[str, str]  # column_alias: description

class ViewBuilder:
    """
    Générateur de VIEWs KPI pour les modules métier
    Architecture modulaire avec templates SQL et préfixes standardisés
    """
    
    def __init__(self):
        self.prefixes = {
            ModuleType.GMAO: "kpi_gmao_",
            ModuleType.STOCKS: "kpi_stocks_",
            ModuleType.PURCHASES: "kpi_purchases_",
            ModuleType.SALES: "kpi_sales_"
        }
        
        # Templates SQL de base pour chaque module
        self.templates = {
            ModuleType.GMAO: self._get_gmao_templates(),
            ModuleType.STOCKS: self._get_stocks_templates(),
            ModuleType.PURCHASES: self._get_purchases_templates(),
            ModuleType.SALES: self._get_sales_templates()
        }
    
    def generate_view_sql(self, view_def: ViewDefinition) -> str:
        """
        Génère le SQL complet pour créer une VIEW
        
        Args:
            view_def: Définition de la VIEW
            
        Returns:
            str: Code SQL complet de création de VIEW
        """
        try:
            view_name = self._build_view_name(view_def.name, view_def.module)
            
            # Construction des colonnes avec commentaires
            columns_sql = self._build_columns_sql(view_def.columns, view_def.comments)
            
            # Construction des JOINs
            joins_sql = self._build_joins_sql(view_def.joins)
            
            # Construction des clauses WHERE
            where_sql = self._build_where_sql(view_def.filters)
            
            # Construction des clauses GROUP BY
            group_by_sql = self._build_group_by_sql(view_def.group_by)
            
            # Construction des clauses ORDER BY
            order_by_sql = self._build_order_by_sql(view_def.order_by)
            
            # Assemblage du SQL final
            sql = f"""-- {view_def.description}
-- Generated by ViewBuilder for module: {view_def.module.value}
-- Base tables: {', '.join(view_def.base_tables)}

CREATE OR REPLACE VIEW {view_name} AS
SELECT
{columns_sql}
FROM {view_def.base_tables[0]}
{joins_sql}
{where_sql}
{group_by_sql}
{order_by_sql};

-- Commentaires sur la VIEW
COMMENT ON VIEW {view_name} IS '{view_def.description}';

-- Commentaires sur les colonnes
{self._build_column_comments_sql(view_name, view_def.comments)}
"""
            
            logger.info(f"SQL généré pour la VIEW {view_name}")
            return sql
            
        except Exception as e:
            logger.error(f"Erreur lors de la génération SQL pour {view_def.name}: {e}")
            raise
    
    def _build_view_name(self, name: str, module: ModuleType) -> str:
        """Construit le nom complet de la VIEW avec préfixe"""
        prefix = self.prefixes[module]
        clean_name = re.sub(r'[^a-zA-Z0-9_]', '_', name.lower())
        return f"{prefix}{clean_name}"
    
    def _build_columns_sql(self, columns: Dict[str, str], comments: Dict[str, str]) -> str:
        """Construit la clause SELECT avec les colonnes"""
        column_lines = []
        for alias, expression in columns.items():
            comment = comments.get(alias, "")
            comment_part = f" -- {comment}" if comment else ""
            column_lines.append(f"    {expression} AS {alias}{comment_part}")
        return ",\n".join(column_lines)
    
    def _build_joins_sql(self, joins: List[str]) -> str:
        """Construit les clauses JOIN"""
        if not joins:
            return ""
        return "\n" + "\n".join(f"    {join}" for join in joins)
    
    def _build_where_sql(self, filters: List[str]) -> str:
        """Construit la clause WHERE"""
        if not filters:
            return ""
        return "\nWHERE\n    " + "\n    AND ".join(filters)
    
    def _build_group_by_sql(self, group_by: List[str]) -> str:
        """Construit la clause GROUP BY"""
        if not group_by:
            return ""
        return "\nGROUP BY\n    " + ",\n    ".join(group_by)
    
    def _build_order_by_sql(self, order_by: List[str]) -> str:
        """Construit la clause ORDER BY"""
        if not order_by:
            return ""
        return "\nORDER BY\n    " + ",\n    ".join(order_by)
    
    def _build_column_comments_sql(self, view_name: str, comments: Dict[str, str]) -> str:
        """Génère les commentaires SQL pour les colonnes"""
        if not comments:
            return ""
        
        comment_lines = []
        for column, description in comments.items():
            if description:
                comment_lines.append(f"COMMENT ON COLUMN {view_name}.{column} IS '{description}';")
        
        return "\n".join(comment_lines)
    
    # Templates SQL pour chaque module métier
    
    def _get_gmao_templates(self) -> Dict[str, ViewDefinition]:
        """Templates de VIEWs pour le module GMAO"""
        return {
            "machine_availability": ViewDefinition(
                name="machine_availability",
                module=ModuleType.GMAO,
                description="KPI de disponibilité des machines par période",
                base_tables=["machines"],
                columns={
                    "machine_id": "m.id",
                    "machine_name": "m.nom",
                    "period_date": "DATE_TRUNC('day', i.date_debut)",
                    "total_hours": "24.0",
                    "downtime_hours": "COALESCE(SUM(EXTRACT(EPOCH FROM (i.date_fin - i.date_debut))/3600), 0)",
                    "availability_rate": "ROUND((24.0 - COALESCE(SUM(EXTRACT(EPOCH FROM (i.date_fin - i.date_debut))/3600), 0)) / 24.0 * 100, 2)",
                    "intervention_count": "COUNT(i.id)"
                },
                joins=[
                    "LEFT JOIN interventions i ON m.id = i.machine_id AND i.date_fin IS NOT NULL"
                ],
                filters=[
                    "m.active = true",
                    "i.date_debut >= CURRENT_DATE - INTERVAL '90 days' OR i.date_debut IS NULL"
                ],
                group_by=[
                    "m.id", "m.nom", "DATE_TRUNC('day', i.date_debut)"
                ],
                order_by=[
                    "period_date DESC", "availability_rate ASC"
                ],
                comments={
                    "machine_id": "Identifiant unique de la machine",
                    "machine_name": "Nom de la machine",
                    "period_date": "Date de la période d'analyse",
                    "availability_rate": "Taux de disponibilité en pourcentage",
                    "downtime_hours": "Heures d'arrêt total"
                }
            ),
            
            "maintenance_costs": ViewDefinition(
                name="maintenance_costs",
                module=ModuleType.GMAO,
                description="Coûts de maintenance par machine et type d'intervention",
                base_tables=["interventions"],
                columns={
                    "machine_id": "m.id",
                    "machine_name": "m.nom",
                    "intervention_type": "i.type_intervention",
                    "month_year": "TO_CHAR(i.date_debut, 'YYYY-MM')",
                    "total_interventions": "COUNT(i.id)",
                    "total_cost": "COALESCE(SUM(i.cout_total), 0)",
                    "avg_cost_per_intervention": "ROUND(COALESCE(AVG(i.cout_total), 0), 2)",
                    "parts_cost": "COALESCE(SUM(i.cout_pieces), 0)",
                    "labor_cost": "COALESCE(SUM(i.cout_main_oeuvre), 0)"
                },
                joins=[
                    "INNER JOIN machines m ON i.machine_id = m.id"
                ],
                filters=[
                    "i.date_debut >= CURRENT_DATE - INTERVAL '12 months'",
                    "i.statut = 'terminee'"
                ],
                group_by=[
                    "m.id", "m.nom", "i.type_intervention", "TO_CHAR(i.date_debut, 'YYYY-MM')"
                ],
                order_by=[
                    "month_year DESC", "total_cost DESC"
                ],
                comments={
                    "total_cost": "Coût total des interventions",
                    "avg_cost_per_intervention": "Coût moyen par intervention",
                    "parts_cost": "Coût des pièces détachées",
                    "labor_cost": "Coût de la main d'œuvre"
                }
            )
        }
    
    def _get_stocks_templates(self) -> Dict[str, ViewDefinition]:
        """Templates de VIEWs pour le module Stocks"""
        return {
            "inventory_turnover": ViewDefinition(
                name="inventory_turnover",
                module=ModuleType.STOCKS,
                description="Rotation des stocks par article et catégorie",
                base_tables=["articles"],
                columns={
                    "article_id": "a.id",
                    "article_name": "a.nom",
                    "category": "a.categorie",
                    "current_stock": "a.stock_actuel",
                    "min_stock": "a.stock_min",
                    "max_stock": "a.stock_max",
                    "units_sold_3m": "COALESCE(SUM(s.quantite), 0)",
                    "turnover_rate": "CASE WHEN a.stock_actuel > 0 THEN ROUND(COALESCE(SUM(s.quantite), 0) / a.stock_actuel, 2) ELSE 0 END",
                    "stock_status": "CASE WHEN a.stock_actuel <= a.stock_min THEN 'LOW' WHEN a.stock_actuel >= a.stock_max THEN 'HIGH' ELSE 'NORMAL' END"
                },
                joins=[
                    "LEFT JOIN sorties_stock s ON a.id = s.article_id AND s.date_sortie >= CURRENT_DATE - INTERVAL '3 months'"
                ],
                filters=[
                    "a.actif = true"
                ],
                group_by=[
                    "a.id", "a.nom", "a.categorie", "a.stock_actuel", "a.stock_min", "a.stock_max"
                ],
                order_by=[
                    "turnover_rate DESC"
                ],
                comments={
                    "turnover_rate": "Taux de rotation sur 3 mois",
                    "stock_status": "Statut du stock (LOW/NORMAL/HIGH)",
                    "units_sold_3m": "Unités vendues sur 3 mois"
                }
            )
        }
    
    def _get_purchases_templates(self) -> Dict[str, ViewDefinition]:
        """Templates de VIEWs pour le module Achats"""
        return {
            "supplier_performance": ViewDefinition(
                name="supplier_performance",
                module=ModuleType.PURCHASES,
                description="Performance des fournisseurs",
                base_tables=["commandes"],
                columns={
                    "supplier_id": "f.id",
                    "supplier_name": "f.nom",
                    "period_month": "TO_CHAR(c.date_commande, 'YYYY-MM')",
                    "total_orders": "COUNT(c.id)",
                    "total_amount": "SUM(c.montant_total)",
                    "on_time_deliveries": "COUNT(CASE WHEN c.date_livraison <= c.date_livraison_prevue THEN 1 END)",
                    "on_time_rate": "ROUND(COUNT(CASE WHEN c.date_livraison <= c.date_livraison_prevue THEN 1 END) * 100.0 / COUNT(c.id), 2)",
                    "avg_delivery_days": "ROUND(AVG(EXTRACT(days FROM (c.date_livraison - c.date_commande))), 1)"
                },
                joins=[
                    "INNER JOIN fournisseurs f ON c.fournisseur_id = f.id"
                ],
                filters=[
                    "c.date_commande >= CURRENT_DATE - INTERVAL '12 months'",
                    "c.statut = 'livree'"
                ],
                group_by=[
                    "f.id", "f.nom", "TO_CHAR(c.date_commande, 'YYYY-MM')"
                ],
                order_by=[
                    "period_month DESC", "on_time_rate DESC"
                ],
                comments={
                    "on_time_rate": "Taux de livraison à temps (%)",
                    "avg_delivery_days": "Délai moyen de livraison (jours)"
                }
            )
        }
    
    def _get_sales_templates(self) -> Dict[str, ViewDefinition]:
        """Templates de VIEWs pour le module Ventes"""
        return {
            "sales_performance": ViewDefinition(
                name="sales_performance",
                module=ModuleType.SALES,
                description="Performance des ventes par période",
                base_tables=["ventes"],
                columns={
                    "sale_date": "DATE_TRUNC('day', v.date_vente)",
                    "week_number": "EXTRACT(week FROM v.date_vente)",
                    "month_year": "TO_CHAR(v.date_vente, 'YYYY-MM')",
                    "daily_revenue": "SUM(v.montant_total)",
                    "daily_transactions": "COUNT(v.id)",
                    "avg_transaction_value": "ROUND(AVG(v.montant_total), 2)",
                    "cumulative_monthly_revenue": "SUM(SUM(v.montant_total)) OVER (PARTITION BY TO_CHAR(v.date_vente, 'YYYY-MM') ORDER BY DATE_TRUNC('day', v.date_vente))"
                },
                joins=[],
                filters=[
                    "v.date_vente >= CURRENT_DATE - INTERVAL '6 months'",
                    "v.statut = 'validee'"
                ],
                group_by=[
                    "DATE_TRUNC('day', v.date_vente)", "EXTRACT(week FROM v.date_vente)", "TO_CHAR(v.date_vente, 'YYYY-MM')"
                ],
                order_by=[
                    "sale_date DESC"
                ],
                comments={
                    "cumulative_monthly_revenue": "Chiffre d'affaires cumulé mensuel",
                    "avg_transaction_value": "Valeur moyenne par transaction"
                }
            )
        }
    
    def get_available_templates(self, module: ModuleType) -> Dict[str, ViewDefinition]:
        """Retourne les templates disponibles pour un module"""
        return self.templates.get(module, {})
    
    def get_all_templates(self) -> Dict[ModuleType, Dict[str, ViewDefinition]]:
        """Retourne tous les templates par module"""
        return self.templates
    
    def validate_view_definition(self, view_def: ViewDefinition) -> Tuple[bool, List[str]]:
        """
        Valide une définition de VIEW
        
        Returns:
            Tuple[bool, List[str]]: (is_valid, list_of_errors)
        """
        errors = []
        
        # Validation du nom
        if not view_def.name or not re.match(r'^[a-zA-Z][a-zA-Z0-9_]*$', view_def.name):
            errors.append("Le nom de la VIEW doit être un identifiant SQL valide")
        
        # Validation des tables de base
        if not view_def.base_tables:
            errors.append("Au moins une table de base doit être spécifiée")
        
        # Validation des colonnes
        if not view_def.columns:
            errors.append("Au moins une colonne doit être définie")
        
        # Validation des alias de colonnes
        for alias in view_def.columns.keys():
            if not re.match(r'^[a-zA-Z][a-zA-Z0-9_]*$', alias):
                errors.append(f"L'alias de colonne '{alias}' n'est pas valide")
        
        return len(errors) == 0, errors

# Instance globale du builder
view_builder = ViewBuilder()
